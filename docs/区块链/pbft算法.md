参考：
- [拜占庭共识算法之PBFT](http://blog.liqilei.com/bai-zhan-ting-gong-shi-suan-fa-zhi-pbftjie-xi/)
- [pbft流程深层分析和解释](http://blog.csdn.net/kojhliang/article/details/71515199)

## 概要
- 异步网络环境下使用状态机副本复制协议
- 提供了(n-1)/3的容错性

## 系统模型
- 消息包含了公钥签名（其实就是RSA算法）、消息验证编码（MAC）和无碰撞哈希函数生成的消息摘要（message digest）

## 服务属性
- 客户端阻塞等待结果
- 安全性要求失效副本的数量不超过上限，但是对客户端失效的数量和是否与副本串谋不做限制。系统通过访问控制来限制失效客户端可能造成的破坏，审核客户端并阻止客户端发起无权执行的操作。
- n=3f+1的由来：假设有f个副本失效，还有n-f的有效副本，有效节点数应该大于失效副本数，而且，有可能有f个有效副本没有回应（网络原因吗？不清楚），因此，n-f>2f，即n>3f。
- 算法不能解决信息保密的问题

## 算法
- 所有的副本在一个被称为视图（View）的轮换过程（succession of configuration）中运作。在某个视图中，一个副本作为主节点（primary），其他的副本作为备份（backups）。
- 主节点失效，则会触发一次视图变更：如果客户端没有在有限时间内收到回复，请求将向所有副本节点进行广播。如果请求已经在副本节点处理过了，副本就向客户端重发一遍执行结果。如果请求没有在副本节点处理过，该副本节点将把请求转发给主节点。如果主节点没有将该请求进行广播，那么就有认为主节点失效，如果有足够多的副本节点认为主节点失效，则会触发一次视图变更。

### 算法主流程
- 1.客户端向主节点发送请求调用服务操作
- 2.主节点通过广播将请求发送给其他副本
- 3.所有副本都执行请求并将结果发回客户端
- 4.客户端需要等待f+1个不同副本节点发回相同的结果，作为整个操作的最终结果。

### 对副本的限定条件
- （1）所有节点必须是确定性的。也就是说，在给定状态和参数相同的情况下，操作执行的结果必须相同；
- （2）所有节点必须从相同的状态开始执行。

### 客户端
- 客户端c向主节点发送<REQUEST,o,t,c>
- 时间戳t用来保证客户端请求只会执行一次。客户端c发出请求的时间戳是全序排列的
- 每个由副本节点发给客户端的消息都包含了当前的视图编号，根据视图推导出主副本，向该节点发送请求
- 客户端等待f+1个从不同副本得到的同样响应，同样响应需要保证签名正确，并且具有同样的时间戳t和执行结果r。

### 算法三阶段流程
预准备（pre-prepare）、准备(prepare)和确认(commit)这三个历史性阶段。预准备和准备两个阶段用来确保同一个视图中请求发送的时序性（即使对请求进行排序的主节点失效了），准备和确认两个阶段用来确保在不同的视图之间的确认请求是严格排序的。

#### 预准备阶段
- 主节点分配一个序列号n给收到的请求，然后向所有备份节点群发预准备消息，预准备消息的格式为<<PRE-PREPARE,v,n,d>,m>
- 只有满足以下条件，各个备份节点才会接受一个预准备消息：
  >请求和预准备消息的签名正确，并且d与m的摘要一致。
  当前视图编号是v。
  该备份节点从未在视图v中接受过序号为n但是摘要d不同的消息m。（许仙在这辈子从未见过名字叫白素贞的美貌女子）
  预准备消息的序号n必须在水线（watermark）上下限h和H之间。
  水线存在的意义在于防止一个失效节点使用一个很大的序号消耗序号空间

#### 准备阶段
- 如果备份节点i接受了预准备消息<<PRE-PREPARE,v,n,d>,m>，则进入准备阶段。在准备阶段的同时，该节点向所有副本节点发送准备消息<PREPARE,v,n,d,i>
- 接受准备消息需要满足的条件
 >包括主节点在内的所有副本节点在收到准备消息之后，对消息的签名是否正确，视图编号是否一致，以及消息序号是否满足水线限制这三个条件进行验证，如果验证通过则把这个准备消息写入消息日志中。

- 准备阶段完成
 >我们定义准备阶段完成的标志为副本节点i将(m,v,n,i)记入其消息日志，其中m是请求内容，预准备消息m在视图v中的编号n，以及2f个从不同副本节点收到的与预准备消息一致的准备消息。每个副本节点验证预准备和准备消息的一致主要检查：视图编号v、消息序号n和摘要d。
预准备阶段和准备阶段确保所有正常节点对同一个视图中的请求序号达成一致。

#### 确认阶段
- 进入确认阶段
>当(m,v,n,i)条件为真的时候，副本i将<COMMIT,v,n,D(m),i>向其他副本节点广播，于是就进入了确认阶段。每个副本接受确认消息的条件是：1）签名正确；2）消息的视图编号与节点的当前视图编号一致；3）消息的序号n满足水线条件，在h和H之间。一旦确认消息的接受条件满足了，则该副本节点将确认消息写入消息日志中。

- 接受确认消息
>我们定义确认完成committed(m,v,n)为真得条件为：任意f+1个正常副本节点集合中的所有副本i其prepared(m,v,n,i)为真；本地确认完成committed-local(m,v,n,i)为真的条件为：prepared(m,v,n,i)为真，并且i已经接受了2f+1个确认（包括自身在内）与预准备消息一致。确认与预准备消息一致的条件是具有相同的视图编号、消息序号和消息摘要。

### 问：为什么要有commit阶段？
答：commit阶段用来确保其他节点都已经收到足够多的信息来达成共识了。Commit阶段并没有像prepare阶段发送同意不同意请求，只检测有没有收到足够多的commit类型信息。

### 问：如果在commit阶段view change，会导致达成不了共识吗？会导致之前的view下的请求编号丢失吗？
答：如果commit阶段viewchange，会保留之前commit阶段的请求，不会达成不了共识，也不会丢失请求编号。

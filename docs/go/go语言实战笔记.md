## chapter2
在Go 语言中，所有变量都被初始化为其零值。对于数值类型，零值是0；对于字符串类型，
零值是空字符串；对于布尔类型，零值是false；对于指针，零值是nil。对于引用类型来说，
所引用的底层数据结构会被初始化为对应的零值。但是被声明为其零值的引用类型的变量，会返
回nil 作为其值。

不仅仅是Go语言，很多语言都允许一个函数返回多个值。一般会像RetrieveFeeds函数这
样声明一个函数返回一个值和一个错误值。如果发生了错误，永远不要使用该函数返回的另一个
值。这个说法并不严格成立，Go 标准库中的io.Reader.Read 方法就允许同时返回数据和错误。但是，如果是
自己实现的函数，要尽量遵守这个原则，保持含义足够明确。

关键字 defer 会安排随后的函数调用在函数返回时才执行。在使用完文件后，需要主动关
闭文件。使用关键字defer 来安排调用Close 方法，可以保证这个函数一定会被调用。哪怕函
数意外崩溃终止，也能保证关键字defer 安排调用的函数会被执行。关键字defer 可以缩短打
开文件和关闭文件之间间隔的代码行数，有助提高代码可读性，减少错误。

我们使用下划线标识符作为别名导入matchers 包，完成了这个调用。这种方法可以让编译器在导入未被引用的包时不报
错，而且依旧会定位到包内的init 函数。

## chapter4
切片内置函数append 会首先使用可用容量。一旦没有可用容量，会分配一个
新的底层数组。这导致很容易忘记切片间正在共享同一个底层数组。一旦发生这种情况，对切片
进行修改，很可能会导致随机且奇怪的问题。对切片内容的修改会影响多个切片，却很难找到问
题的原因。如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个append 操作
创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行
后续修改，如代码清单4-36 所示。

映射的键可以是任何值。这个值的类型可以是内置的类型，也可以是结构类型，只要这个值
可以使用==运算符做比较。切片、函数以及包含切片的结构类型这些类型由于具有引用语义，
不能作为映射的键，使用这些类型会造成编译错误

## chapter5
是使用值接收者还是指针接收者，不应该由该方法是否修改了接收到的值来决定。这个决策
应该基于该类型的本质。这条规则的一个例外是，需要让类型值符合某个接口的时候，即便类型
的本质是非原始本质的，也可以选择使用值接收者声明方法。这样做完全符合接口值调用方法的
机制。

由于内部类型的提升，内部类型实现的接口会自动提升到外部类型。
